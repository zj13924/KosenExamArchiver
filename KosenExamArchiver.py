import sys
import os
import threading
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from datetime import datetime, timedelta, timezone

import fitz  # PyMuPDF

# --- CONSTANTS & CONFIG ---
JST = timezone(timedelta(hours=9))
NOW_JST = datetime.now(JST)
VER_DATE = NOW_JST.strftime("%Y%m%d")

# Clean Title for the GUI Window
APP_TITLE = f"Kosen Exam Archiver ver. {VER_DATE}"

# Full "Creator" string for PDF Metadata (includes URL for traceability)
REPO_URL = "https://github.com/zj13924/KosenExamArchiver"
APP_CREATOR_INFO = f"{APP_TITLE}  {REPO_URL}"

# --- ABOUT TEXT CONTENT ---
ABOUT_TEXT = f"""{APP_TITLE}

[ Repository ]
{REPO_URL}

[ Purpose ]
This application is a specialized compression tool designed for archiving scanned exam answer sheets at Kosen.
It features specific algorithms to:
  - "Bleach" paper backgrounds to pure white.
  - Strongly emphasize red ink and pencil marks.
  - Flatten all vector layers into a single raster image to ensure long-term evidence preservation.

* WARNING: While this tool can compress general PDF documents, it may produce poor results (e.g., loss of color accuracy, artifacts) on non-exam documents due to its aggressive optimization for handwriting visibility.

[ AI Declaration ]
The source code of this application was fully generated by Google Gemini. The user did not write a single line of the code manually.

[ License & Credits ]
1. PyMuPDF (fitz)
   - Rendering and PDF manipulation engine.
   - License: GNU AGPL v3.0 / Commercial
   - https://pymupdf.readthedocs.io/

2. TkinterDnD2
   - Drag-and-drop support for GUI.
   - License: MIT License
   - https://github.com/pmgagne/tkinterdnd2

3. App Icon
   - Based on 'emoji_u1f4e5.png' from the Google Noto Emoji project.
   - Modified by adding custom text overlay.
   - License: Apache License 2.0
   - https://github.com/googlefonts/noto-emoji

[ Disclaimer ]
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""


# --- RESOURCE PATH HELPER ---
def resource_path(relative_path):
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)


# --- DND FIX ---
def fix_dnd_path():
    if getattr(sys, "frozen", False):
        dnd_path = os.path.join(sys._MEIPASS, "tkinterdnd2")
        os.environ["TKDND_LIBRARY"] = dnd_path


fix_dnd_path()

try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
except ImportError:
    print("CRITICAL ERROR: 'tkinterdnd2' library is missing.")
    sys.exit(1)

# ========================================================
#  LOGIC ENGINE
# ========================================================


def get_pdf_timestamp():
    now = datetime.now().astimezone()
    ts = now.strftime("D:%Y%m%d%H%M%S")
    tz_seconds = now.utcoffset().total_seconds()
    hours = int(abs(tz_seconds) // 3600)
    minutes = int((abs(tz_seconds) % 3600) // 60)
    sign = "+" if tz_seconds >= 0 else "-"
    return f"{ts}{sign}{hours:02d}'{minutes:02d}'"


def build_lookup_table(threshold):
    lut = bytearray(range(256))
    for i in range(threshold, 256):
        lut[i] = 255
    return bytes(lut)


def get_unique_path(base_dir, base_name, ext):
    output_path = os.path.join(base_dir, f"{base_name}{ext}")
    counter = 1
    while os.path.exists(output_path):
        output_path = os.path.join(base_dir, f"{base_name}_{counter}{ext}")
        counter += 1
    return output_path


def process_page_to_doc(page, out_doc, dpi, quality):
    zoom = dpi / 72
    pix = page.get_pixmap(matrix=fitz.Matrix(zoom, zoom), alpha=False)

    ratio, top_color = pix.color_topusage()
    bg_brightness = sum(top_color) // len(top_color)

    if bg_brightness > 200:
        threshold = max(0, bg_brightness - 15)
        lut = build_lookup_table(threshold)
        clean_samples = pix.samples.translate(lut)
        pix = fitz.Pixmap(
            pix.colorspace, pix.width, pix.height, clean_samples, pix.alpha
        )

    img_bytes = pix.tobytes("jpeg", jpg_quality=quality)
    new_page = out_doc.new_page(width=page.rect.width, height=page.rect.height)
    new_page.insert_image(new_page.rect, stream=img_bytes)


def count_total_pages(file_queue):
    total_pages = 0
    for path in file_queue:
        try:
            with fitz.open(path) as doc:
                total_pages += len(doc)
        except:
            pass
    return total_pages


def worker_batch_job(
    file_queue, merge_mode, dpi, quality, callback_log, callback_step, callback_finish
):
    success_count = 0
    total_files = len(file_queue)
    current_user = os.environ.get("USERNAME", "Unknown User")
    timestamp = get_pdf_timestamp()

    if merge_mode:
        try:
            master_doc = fitz.open()
            first_file = file_queue[0]
            base_dir = os.path.dirname(first_file)
            base_name_original = os.path.splitext(os.path.basename(first_file))[0]

            final_name_base = f"{base_name_original}_compressed_merged"
            output_path = get_unique_path(base_dir, final_name_base, ".pdf")

            for idx, input_path in enumerate(file_queue):
                filename = os.path.basename(input_path)
                callback_log(f"Merging {idx+1}/{total_files}: {filename}...")
                try:
                    src_doc = fitz.open(input_path)
                    for page in src_doc:
                        process_page_to_doc(page, master_doc, dpi, quality)
                        callback_step()
                    success_count += 1
                except Exception as e:
                    callback_log(f"ERROR on {filename}: {e}")

            callback_log(f"Saving to: {os.path.basename(output_path)}...")
            master_doc.set_metadata(
                {
                    "title": os.path.basename(output_path),
                    "author": current_user,
                    "creator": APP_CREATOR_INFO,  # Includes URL
                    "producer": "PyMuPDF",
                    "creationDate": timestamp,
                    "modDate": timestamp,
                }
            )
            master_doc.save(output_path, garbage=4, deflate=True)
        except Exception as e:
            callback_log(f"CRITICAL MERGE ERROR: {e}")

    else:
        for idx, input_path in enumerate(file_queue):
            filename = os.path.basename(input_path)
            callback_log(f"Processing {idx+1}/{total_files}: {filename}...")
            try:
                base_dir = os.path.dirname(input_path)
                base_name_original = os.path.splitext(os.path.basename(input_path))[0]

                final_name_base = f"{base_name_original}_compressed"
                output_path = get_unique_path(base_dir, final_name_base, ".pdf")

                src_doc = fitz.open(input_path)
                out_doc = fitz.open()
                for page in src_doc:
                    process_page_to_doc(page, out_doc, dpi, quality)
                    callback_step()
                out_doc.set_metadata(
                    {
                        "title": os.path.basename(output_path),
                        "author": current_user,
                        "creator": APP_CREATOR_INFO,  # Includes URL
                        "producer": "PyMuPDF",
                        "creationDate": timestamp,
                        "modDate": timestamp,
                    }
                )
                out_doc.save(output_path, garbage=4, deflate=True)
                success_count += 1
            except Exception as e:
                callback_log(f"ERROR on {filename}: {e}")

    callback_finish(success_count, total_files)


# ========================================================
#  GUI CLASS
# ========================================================


class ExamArchiverApp(TkinterDnD.Tk):
    def __init__(self):
        super().__init__()

        self.title(APP_TITLE)  # Clean Title (No URL)
        self.geometry("650x600")

        try:
            icon_file = resource_path("emoji_u1f4e5.ico")
            self.iconbitmap(icon_file)
        except Exception:
            pass

        self.file_queue = []

        # --- UI SETUP ---
        frame_top = ttk.LabelFrame(self, text="Settings", padding=10)
        frame_top.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(frame_top, text="DPI:").pack(side=tk.LEFT, padx=(5, 2))
        self.combo_dpi = ttk.Combobox(frame_top, width=5, state="normal")
        self.combo_dpi["values"] = ("96", "150", "200", "300")
        self.combo_dpi.set("150")
        self.combo_dpi.pack(side=tk.LEFT, padx=5)

        ttk.Label(frame_top, text="JPEG Quality:").pack(side=tk.LEFT, padx=(15, 2))
        self.combo_qual = ttk.Combobox(frame_top, width=5, state="normal")
        self.combo_qual["values"] = ("10", "25", "50", "75")
        self.combo_qual.set("10")
        self.combo_qual.pack(side=tk.LEFT, padx=5)

        self.btn_about = ttk.Button(
            frame_top, text="About", width=6, command=self.show_about
        )
        self.btn_about.pack(side=tk.RIGHT, padx=5)

        self.var_merge = tk.BooleanVar(value=False)
        self.chk_merge = ttk.Checkbutton(
            frame_top, text="Merge all into one PDF", variable=self.var_merge
        )
        self.chk_merge.pack(side=tk.RIGHT, padx=15)

        # --- LIST AREA ---
        frame_mid = ttk.Frame(self)
        frame_mid.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        frame_order = ttk.Frame(frame_mid)
        frame_order.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 5))

        self.btn_up = ttk.Button(frame_order, text="↑", width=3, command=self.move_up)
        self.btn_up.pack(pady=2)
        self.btn_down = ttk.Button(
            frame_order, text="↓", width=3, command=self.move_down
        )
        self.btn_down.pack(pady=2)

        frame_list = ttk.Frame(frame_mid)
        frame_list.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        lbl_instr = ttk.Label(
            frame_list, text="Drag PDF files here (or use 'Select Files'):"
        )
        lbl_instr.pack(anchor="w")

        scrollbar = ttk.Scrollbar(frame_list)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.listbox = tk.Listbox(
            frame_list,
            selectmode=tk.EXTENDED,
            yscrollcommand=scrollbar.set,
            bg="#f0f0f0",
        )
        self.listbox.pack(fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.listbox.yview)

        self.listbox.drop_target_register(DND_FILES)
        self.listbox.dnd_bind("<<Drop>>", self.handle_drop)

        # --- BUTTONS ---
        frame_btns = ttk.Frame(self)
        frame_btns.pack(fill=tk.X, padx=10, pady=5)

        self.btn_browse = ttk.Button(
            frame_btns, text="Select Files...", command=self.browse_files
        )
        self.btn_browse.pack(side=tk.LEFT)
        self.btn_remove = ttk.Button(
            frame_btns, text="Remove Selected", command=self.remove_selected
        )
        self.btn_remove.pack(side=tk.LEFT, padx=5)
        self.btn_clear = ttk.Button(
            frame_btns, text="Clear List", command=self.clear_all
        )
        self.btn_clear.pack(side=tk.LEFT, padx=5)
        self.btn_start = ttk.Button(
            frame_btns, text="START PROCESSING", command=self.start_processing
        )
        self.btn_start.pack(side=tk.RIGHT)

        self.progress = ttk.Progressbar(self, orient=tk.HORIZONTAL, mode="determinate")
        self.progress.pack(fill=tk.X, padx=10, pady=(0, 5))

        self.status_var = tk.StringVar()
        self.status_var.set("Ready.")
        self.lbl_status = ttk.Label(
            self, textvariable=self.status_var, relief=tk.SUNKEN, anchor="w"
        )
        self.lbl_status.pack(fill=tk.X)

        self.after(100, self.check_startup_args)

    # --- ABOUT WINDOW ---
    def show_about(self):
        about_win = tk.Toplevel(self)
        about_win.title("About This App")
        about_win.geometry("500x550")

        txt = tk.Text(about_win, wrap=tk.WORD, padx=10, pady=10)
        txt.pack(fill=tk.BOTH, expand=True)

        txt.insert(tk.END, ABOUT_TEXT)
        txt.config(state=tk.DISABLED)

        btn_close = ttk.Button(about_win, text="Close", command=about_win.destroy)
        btn_close.pack(pady=5)

    # --- REORDERING LOGIC ---
    def move_up(self):
        selection = self.listbox.curselection()
        if not selection:
            return
        for i in selection:
            if i == 0:
                continue
            text = self.file_queue.pop(i)
            self.file_queue.insert(i - 1, text)
            self.listbox.delete(i)
            self.listbox.insert(i - 1, text)
            self.listbox.selection_set(i - 1)

    def move_down(self):
        selection = self.listbox.curselection()
        if not selection:
            return
        for i in reversed(selection):
            if i == self.listbox.size() - 1:
                continue
            text = self.file_queue.pop(i)
            self.file_queue.insert(i + 1, text)
            self.listbox.delete(i)
            self.listbox.insert(i + 1, text)
            self.listbox.selection_set(i + 1)

    # --- STANDARD HANDLERS ---
    def check_startup_args(self):
        if len(sys.argv) > 1:
            files_to_add = sys.argv[1:]
            self.ingest_paths(files_to_add)

    def browse_files(self):
        files = filedialog.askopenfilenames(filetypes=[("PDF Files", "*.pdf")])
        if files:
            self.ingest_paths(files)

    def handle_drop(self, event):
        raw_data = event.data
        if not raw_data:
            return
        try:
            raw_data = raw_data.encode("latin-1").decode("utf-8")
        except UnicodeError:
            pass
        try:
            paths = self.tk.splitlist(raw_data)
        except:
            paths = [raw_data]
        self.ingest_paths(paths)

    def ingest_paths(self, paths):
        count = 0
        for p in paths:
            if os.path.isdir(p):
                for root, _, files in os.walk(p):
                    for f in files:
                        if f.lower().endswith(".pdf") and "_compressed" not in f:
                            self.add_file_to_list(os.path.join(root, f))
                            count += 1
            elif os.path.isfile(p) and p.lower().endswith(".pdf"):
                self.add_file_to_list(p)
                count += 1
        if count > 0:
            self.log(f"Added {count} files to queue.")

    def add_file_to_list(self, path):
        path = os.path.normpath(path)
        if path not in self.file_queue:
            self.file_queue.append(path)
            self.listbox.insert(tk.END, path)

    def remove_selected(self):
        selection = self.listbox.curselection()
        for i in reversed(selection):
            del self.file_queue[i]
            self.listbox.delete(i)

    def clear_all(self):
        self.file_queue = []
        self.listbox.delete(0, tk.END)

    def log(self, message):
        self.status_var.set(message)

    def start_processing(self):
        if not self.file_queue:
            messagebox.showwarning("Empty Queue", "Please add some PDF files.")
            return

        try:
            dpi = int(self.combo_dpi.get())
            qual = int(self.combo_qual.get())
        except ValueError:
            return

        merge_mode = self.var_merge.get()

        self.btn_start.config(state=tk.DISABLED)
        self.btn_browse.config(state=tk.DISABLED)

        self.log("Counting pages...")
        t = threading.Thread(target=self.init_worker, args=(merge_mode, dpi, qual))
        t.start()

    def init_worker(self, merge_mode, dpi, qual):
        total_pages = count_total_pages(self.file_queue)
        self.progress.after(0, lambda: self.set_progress_max(total_pages))
        worker_batch_job(
            self.file_queue,
            merge_mode,
            dpi,
            qual,
            self.update_log,
            self.step_progress,
            self.finish_batch,
        )

    def set_progress_max(self, val):
        self.progress["maximum"] = val
        self.progress["value"] = 0

    def update_log(self, msg):
        self.lbl_status.after(0, self.log, msg)

    def step_progress(self):
        self.progress.after(0, lambda: self.progress.step(1))

    def finish_batch(self, success, total_files):
        self.lbl_status.after(0, self.finalize_ui, success, total_files)

    def finalize_ui(self, success, total_files):
        self.log(f"Done. {success}/{total_files} files processed.")
        messagebox.showinfo("Complete", f"Processed {success} of {total_files} files.")
        self.progress["value"] = 0
        self.btn_start.config(state=tk.NORMAL)
        self.btn_browse.config(state=tk.NORMAL)


if __name__ == "__main__":
    app = ExamArchiverApp()
    app.mainloop()
